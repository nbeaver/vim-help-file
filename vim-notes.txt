*vim-notes.txt*	Personal vim notes.


1. Vim help tag prefix conventions.
2. Command list.

================================================================================
1. Vim help tag prefix conventions and notation.

      Description                                   Example#1  Example#2     Reference
--------------------------------------------------- -------------------------------------------------
      No prefix for keystrokes in normal mode.      |CTRL-R|     |<Up>|          |Normal-mode| |command-mode|
i_    Tag prefix for keystrokes in insert mode.     |i_CTRL-R|   |i_<Up>|        |Insert-mode|
:     Tag prefix for ranges and ex commands.        |:%|         |:shell|        |:|
:_    Tag prefix for characters in cmdline mode.    |:_%|        |:_!|           |Cmdline-mode|
c_    Usually same as the :_ prefix.                |c_%|        |c_CTRL-C|      |Cmdline-mode|
v_    Tag prefix for keystrokes in visual mode.     |v_!|        |v_CTRL-C|      |Visual-mode|
/     Tag prefix for patterns.                      |/star|      |/.|            |pattern-overview|
s_    Tag prefix for substitution flags.            |:s_c|                       |:s_flags|
quote Tag prefix for registers.                     |quote-|     |quote_alpha|   |registers|
-     Tag prefix for arguments when invoking Vim.   |-+|         |-c|            |vim-arguments|
t_    Tag prefix for termcap flags.                 |t_k5|       |t_cm|          |terminal-options|
+     Tag prefix for features.                      |+visual|    |+syntax|       |+feature-list|
Vim |options| are in single quotes.                 |'ic'|       |'noic'|        |set-option|
Vim error numbers start with E.                     |E10|        |E849|          |error-messages|
Special key names are in angle brackets.            |<BS>|       |<F1>|          |key-notation|
Optional parts of a command are in square brackets. |[count]|    |[quotex]|      |notation|
Required parts of a command are in curly brackets.  |{motion}|   |{Visual}|      |{}|
Character class expressions are in [: :].           |[:alpha:]|  |[:cntrl:]|     |[:alnum:]|

	http://vim.wikia.com/wiki/Learn_to_use_help#Context

Formatting conventions:
-- Make unindented text correspond to actual keystrokes,
   so a search for e.g. "^I" will jump to the "I" keystroke in any mode.
-- Make sure that external commands (e.g. wc(1)) can be followed with |K|,
   e.g. wc(1) doesn't work, nor at the end of sentence ( wc. ), but wc (1) is
   fine, as is /usr/bin/wc (with no period after).
-- Indent URLs with <Tab>.
-- Mark up output text as examples: >
	This is some output text.
< End the example with an angle bracket.

	*Todo	change <Enter> to <CR>.
	*Todo	change {motion} to {move-around} if it's more than one motion command.

==============================================================================
2. List of commands.

:w | sh			Write file and jump to shell,
			with Ctrl-D to jump back. |:write| |:shell|

Ctrl-]			Jump to tag under cursor. |Ctrl-]| |tag-regexp|
			Current buffer must be saved.

Ctrl-t			Jump to last tag. |CTRL-T|
			Note: Unlike Ctrl-O, Ctrl-I will not jump forward again.

Ctrl-w Ctrl-]		Open tag in new window. |CTRL-W_]|

	http://vim.wikia.com/wiki/Follow_tag_in_new_window

v			Begin visual selection. |characterwise-visual|

v			End visual selection. |v_v|
			*Todo	train myself to do this instead of Esc.

vw			Select a word, starting from the current cursor position
			and ending at the start of the next word.

viw			Select a word if you are at the beginning, end,
			or somewhere in the middle. |v_iw|

vis			Select the sentence the cursor is in. |v_is|

vi"			Select between quotes. |v_iquote|

va"			Inclusive select between quotes. |v_aquote|

vib			Select parenthesis block. |v_ib|

viB			Select curly braces block. |v_iB|

d%			When on a bracket, e.g. ( [ { } ] ),
			delete bracket, matching bracket, and everything in between. |d| |%| |inclusive|

dt<Space>		Delete until space.
			(Usually dW does the same thing and is faster.)

I			Enter insert mode at end of indentation on current line. |I|

gI			Enter insert mode at beginning of line. |gI|

			Add '#' in front of several lines.
			Useful for commenting out blocks of code.
Ctrl-v{motion}		Blockwise visual selection. |CTRL-V| |blockwise-visual|
I			Now move into insert mode at the beginning of each line. |v_b_I|
#			Now type the comment character, e.g. #
Esc			Now get out of insert mode. |i_esc|

			Put contents of the last yank in front of multiple contiguous lines.
I			Now move into insert mode at the beginning of each line. |v_b_I|
Ctrl-r "		Paste the last yank. |i_CTRL-R|
			Can use any register, not just |quote_quote|. |registers|

			Add # in front of several lines, but using linewise visual mode
			instead of block visual mode. |linewise-visual|
V			Enter linewise visual mode. |V|
:s/^/#/			Use the |:substitute| command to replace the |/^| pattern atom with '#'. |pattern-atoms|
			It will look like this while typing: >
				:'<,'>s/^/#/

:s/\s\+/\r/g		Split a line with words and whitespace into several lines with one word per line.
			Also strips whitespace. |:substitute| |/\+|

			Append "hi" to several lines using blockwise-visual mode.
Ctrl-v{motion}		Blockwise visual selection. |CTRL-V| |blockwise-visual|
$      			Move to end of each line. |v_$|
A			Enter insert mode after the cursor. |A|
hi			Type the desired text.
<Esc>			Exit insert mode.

:.,.+5s/$/hi		Append "hi" to 5 lines using ex command. |:.| |:,| |:s|

			Append "hi" to several lines using linewise visual mode. |linewise-visual|
V{motion}		Select the text. |V|
:norm Ahi		Apply the normal mode command to the selected lines. |:normal| |A|
			Looks like this when typed: >
				:'<,'>norm Ahi

''			Toggle previous cursor position. |''| |``|


/ Ctrl-R 0		Search for yanked text. Breakdown:
/			Begin search. |/|
Ctrl-R			Enter contents of register. |i_CTRL-R|
0			Paste yanked text. |quote0|

/ Ctrl-R +		Search for clipboard text. Breakdown:
/			Begin search. |/|
Ctrl-R			Enter contents of register. |i_CTRL-R|
+			Paste yanked text. |quote+|

q/p<Enter>		Search for yanked text. Breakdown:
q/			Open |command-line-window|.
p			Paste last yank.

	http://vim.wikia.com/wiki/Search_and_replace_in_a_visual_selection#Searching_with_.2F_and_.3F
	http://vim.wikia.com/wiki/Search_for_visually_selected_text

*			Search forward for word under cursor. |star|
			Note: this does not work for a visual selection.

#			Search backward for word under cursor. |#|
			Note: this does not work for a visual selection.

			Re-open a recently closed tab.
:ls			Check if it's in the list of open buffers. |:ls|
:tabnew#		Often, it will be the alternate file buffer, '#'. |:_#|  |alternate-file|
:tabnew +11buf		Otherwise, open the appropriate buffer number (11 in this case). |+cmd| |:buf|
:tabnew \+11buf		If you actually want to open a {file} called "+11buf".

	https://stackoverflow.com/questions/571955/undo-close-tab-in-vim

:browse oldfiles	Look at recently edited files,
			with the option to open one of them. |:oldfiles| |more-prompt|

	https://stackoverflow.com/questions/3171284/recent-file-history-in-vim

:set			Show options that are different from the default value. |:set|

:set ic			Case-insensitive search. |'ignorecase'|

/foo\c			Case-insensitive search (for current search only). |/\c|

:%s/foo/bar/gci		Change each 'foo' (case insensitive) to 'bar' starting from the top of the file; ask for confirmation.
			The % is short for 1,$ (the entire file). |:%| |:range|
			The /g is for global substitution (not just once per line). |:s_flags|
			The /c is for confirmation on each substitution. |:s_c|
			The /i is for case-insensitivity. |:s_flags|

:.,$s/foo/bar/gci	Change each 'foo' (case insensitive) to 'bar' starting with current line.
			The '.' means current line and the '$' means last line. |:.| |:$| |:range|
:,$s/foo/bar/gci	Since starting from the current line is assumed,
			it can also be omitted entirely.

:%s;/home/user1;/home/user2;gc
			Subsitute file paths without escaping all the / characters.
			Using a slash for the substitute command is not necessary. |E146|
			You can use anything except an alphanumeric character, \, ", or |

:%s/blah//gn		Count number of matches the pattern "blah".
			There may be multiple matches per line. |count-items|

:%s/^+//n		Count number of lines starting with + sign.
			Useful for counting number of added lines in a patch.

:.,$s/foo/bar/gci	Change each 'foo' (case insensitive) to 'bar',
			starting from the current line; ask for confirmation.

:%s/,/\r/g		Replace all commas with newlines. |/\r|

:edit			Reload current file. |:edit|

:set laststatus=2	Always view status bar. |status-line| |'laststatus'|

Ctrl-a			Increment a number. |CTRL-A|

Ctrl-x			Decrement a number. |CTRL-X|

Ctrl-i			Jump forward through jumplist. |CTRL-I| |<Tab>|

Ctrl-o			Jump backward through jumplist. |CTRL-O|

:ju			See all jumps in the jumplist. |:jumps|

:set autochdir		Set working directory to directory of current file. |'autochdir'|

Ctrl-g			Find name of current file and other helpful information. |CTRL-G| |:file|

g Ctrl-g		Count characters in file. |g_CTRL-G| |word-count| |byte-count|
{Visual}g Ctrl-g	Count characters in visual selection.

:pwd			Find out the current working directory. |:pwd|

!!pwd			Overwrite current line with directory vim was invoked in,
			or path of buffer if autochdir is set.  |!!| |filter| |'autochdir'|
			Looks like this when typed: >
	:.!pwd

Ctrl-R %		Put/paste filename in insert mode. |:_%|
			May include path, depending on how vim was invoked.

"%p			Put/paste filename in normal mode. |quote%|
			May include path, depending on how vim was invoked.

:let @" = expand("%")	Yank filename to the unnamed register. |:_%| |expand()| |:let|

:let @" = expand("%:p")	Yank full path to the unnamed register. |%:p| |expand()| |:let|

	https://stackoverflow.com/questions/916875/yank-file-name-path-of-current-buffer-in-vim

{			Move up to next blank line. |{| |object-motions|

}			Move down to next blank line. |}| |object-motions|

]]			Move to next '{' in the first column. |]]| |object-motions|

[[			Move to previous '}' in the first column. |[[| |object-motions|

:set comments=sl:/*,mb:**,elx
			C-style multi-line comments. |'comments'| |format-comments|
			Start left aligned with /*, continue with ** followed by a blank, end by typing the last character.

	http://tldp.org/HOWTO/C-editing-with-VIM-HOWTO/auto-format.html#AEN274

d0			Delete everything before cursor on line. |d|

D			Delete everything after cursor on line. |D|

:set makeprg=gcc\ test.c
			Set |:make| command to run "gcc test.c". |'makeprg'|

:set makeprg=gcc\ %
			Set |:make| command to run gcc on current filename. |:_%|

:nnoremap <F5> :<C-U>make<CR>
			Bind <F5> key run |:make|.
			The |c_CTRL-U| is there to clear the line of any previous commands.

:%s/\t/\n/g		Replace tabs with newlines.

Ctrl-V Ctrl-I		Insert tab character when |'expandtab'| is set. |i_CTRL-V|

:set list		View whitespace and non-printing characters in current file. |'list'|
:tabdo set list		Do this for all buffers. |:bufdo|
:bufdo set list		Do this for all windows. |:windo|
:windo set list		Do this for all tabs. |:tabdo|
:set nolist		Stop viewing whitespace in current file.

Ctrl-]			Jump to help tags like |tag-commands|

set tags		See which files vim looks for tags in. |'tags'| |E433|

:! wc %			Word count of current file using external /usr/bin/wc shell command. |:!| |:_%| |c_%|

			Jump to the longest line in the current file.
			Uses the external /usr/bin/wc command.
:r !wc -L %		Get the length of the longest line, e.g. >
	137 myfile.txt
/\%137c			Jump to column #137. |/\%c|
			“What! That is far too complex for such a simple task!” cried the student.
	http://blog.sanctum.geek.nz/vim-koans/
			

	https://stackoverflow.com/questions/2075276/longest-line-in-vim
	https://superuser.com/questions/255368/how-to-find-the-line-with-the-maximum-number-of-columns-characters-in-vim-gvim
	http://of-vim-and-vigor.blogspot.com/2012/02/jump-to-longest-line.html

Ctrl-X Ctrl-F		Auto-complete filenames while in insert mode.
			|i_CTRL-X_CTRL-F|	|compl-filename|
			|i_CTRL-X|		|insert_expand|

:tabnew | r !w3m http://en.wikipedia.org/wiki/Vi -dump
			Dump Wikipedia page into new tab. |:r| |:!|
			Requires external /usr/bin/w3m browser.
	http://sourceforge.net/projects/w3m/
	http://manoftoday.wikidot.com/vim#toc19
	http://www.linux.com/learn/tutorials/442419-vim-tips-working-with-external-commands


			Run the current line as a shell command
V			Select current line. |V|
:w !sh			Execute the selected text with /bin/sh (default shell).
			Looks like this when typed: >
				'<,'>w !sh
:w !bash	 	Can also use e.g. bash shell.

:! my-shell-command	Running shell commands

u			Undo. |u|
Ctrl-r			Redo. |CTRL-R|

Ctrl-r "		Inserting/pasting registers in command mode. |c_CTRL-R|

Ctrl-y			Scroll window up without moving cursor. |CTRL-Y|
Ctrl-e			Scroll window down without moving cursor. |CTRL-E|
			
			Insert the current time in insert mode.
<C-R>=			Bring up expression register. |i_CTRL-R_=|
strftime("%c")		Get time. |strftime()|
<CR>			End expression and go back to insert mode.

			Remap keys so that moving over long lines is easier. |:noremap|
:noremap k gk		Map |k| to |gk| in normal mode, visual mode, and operator-pending mode.
:noremap j gj		Map |j| to |gj|.

			Undo the mapping. |:unmap|
:unmap k		These must be done one at a time. |E31|
:unmap j		Otherwise it's not clear what the mapping is.

			Deleting (e.g. |d| and |x|) affects unnamed register (|quotequote|) and therefore |p|,
			so how do we overwrite text? One fairly easy way:
yy			Yank current line. |yy|
{motion}		Move to desired line to replace.
dd			Delete the line. |dd|
"0p			Paste the first line. |quote0| |p|
	http://vim.wikia.com/wiki/Replace_a_word_with_yanked_text
	https://serebrov.github.io/html/2012-04-03-vim-replace-word-with-yanked-text.html
	http://osquestions.com/unix-linux/26654/how-can-i-paste-overwriting-with-vim
	https://superuser.com/questions/321547/how-do-i-replace-paste-yanked-text-in-vim-without-yanking-the-deleted-lines

			Another way to overwrite text easily using registers. |quote_alpha|
{Visual}"ay		Yank visual selection into register a. |{Visual}| |y|
"ap			Paste register a. |p|

"*p			Paste primary selection (same as middle click). |quotestar|

"+p			Paste clipboard (same as Ctrl-V in other programs). |quote+|
			If you want to paste in a web address,
			this is much better than using your terminal to paste (e.g. with Ctrl-Shift-V).
			If you aren't in insert mode and use Ctrl-Shift-V,
			it will interpret the ':' in 'http:' as entering command mode.
			Also, for large amounts of text Ctrl-Shift-V tends to be much slower.

"+y			Copy current line to clipboard. |quote+|
{Visual}"+y		Copy visual selection to clipboard. |quote+|
			(Behaves like Ctrl-C in other text editors.)

{Visual}"*y		Copy visual selection into primary clipboard selection.
			(Behaves like middle mouse button selection.)

{Visual}"*x		Cut visual selection into primary clipboard selection. |quotestar|
			Paste it with middle mouse button.

			Before pasting into vim,
:set nopaste		turn off autowrap and such. |'paste'|
:set paste		Then turn it all back on.

:set wrap		Wrap long lines.
:set nowrap		Don't wrap long lines.
			Admittedly, a command like >
				:set unwrap
<			would make more sense,
			but this is consistent with other options.

:help i_<command>	Help on command in insert mode. Example: >
				:help i_CTRL-X_CTRL-L

gf			Open filename or path under cursor. |gf|
			Must save current file first. |E37|
			(Use |CTRL-W_f| if you don't want to |abandon| the file.)
			Path must not contain spaces. |'isfname'| |E447|
			*Todo	is there a way to make vim follow paths with escaped spaces?


			Open selected file or path, regardless of |'isfname'|.
v{motion}		Select path, including spaces.
gf			Jump to file. |v_gf|
			Useful for e.g. opening paths containing spaces.

Ctrl-W f		Open filename under cursor in new window. |CTRL-W_f| |CTRL-W_CTRL-F|

Ctrl-W =		Make each window about the same height. |CTRL-W_=|

Ctrl-W o		Make the current window maximized so that it expands to fill the entire viewport. |CTRL-W_o|

Ctrl-W T		Move window to a new tab. |CTRL-W_T|

:resize 90		Resize window height to 90 lines. |:resize|

	http://vim.wikia.com/wiki/Resize_splits_more_quickly

ga			Inspect character for decimal, hex, or octal representation, e.g.  >
				<ñ> 241, Hex 00f1, Octal 361
<			Useful combined with /usr/bin/unicode command. |ga| |:ascii| >
				$ unicode 00f1
				U+00F1 LATIN SMALL LETTER N WITH TILDE
				UTF-8: c3 b1  UTF-16BE: 00f1  Decimal: &#241;
				ñ (Ñ)
				Uppercase: U+00D1
				Category: Ll (Letter, Lowercase)
				Bidi: L (Left-to-Right)
				Decomposition: 006E 0303
<

g8			Inspect hex bytes of UTF-8. |g8|
			(Not useful for searching with /usr/bin/unicode command.)

			While Vim can search for Unicode characters directly,
			sometimes it is useful to be able to search by Unicode value.
/\%d173			Search for the soft hyphen by its decimal value 0x00ad. |/\%d|
/\%xad			Search for the soft hyphen by its hexadecimal value 0x00ad. |/\%x|
/\%o255			Search for the soft hyphen by its octal value 0255. |/\%o|

:s/\%xad//g		Remove all the soft hyphens on the current line.

			Examples of entering digraphs in insert mode. |i_CTRL-K|
Ctrl-K n?		Enter an ñ (enye).
Ctrl-K DG		Enter the degree symbol, °
Ctrl-K DE		Enter the section sign, §
	https://en.wikipedia.org/wiki/%C3%91
	https://en.wikipedia.org/wiki/Degree_symbol
	https://en.wikipedia.org/wiki/Section_sign

:digraphs		See all available digraphs. |:digraphs|

:%!nl			Put line numbers into file using external /usr/bin/nl command.

			Number a visual selection.
{Visual}:!nl		Run through external command.
			Looks like this: >
				:'<,'>!nl
<
:%!tac			Reverse order of lines using external /usr/bin/tac command.

			Sorting with external /usr/bin/sort command.
:!4,7!sort		Sort lines 4-7.
:4,$ !sort		Sort lines 4 to end of document.
{Visual}:!sort		Sort visual selection.

			Sorting with internal Vim command, |:sort|.
:sort			Sort alphabetically.
:sort!			Sort alphabetically in reverse order.
:sort u			Sort alphabetically, removing duplicates (unique).
:sort n			Sort numerically instead of alphabetically.
:sort /.*\%52v/		Sort visual selection based on 52nd character.
			Looks like this when typed: >
				:'<,'>sort /.*\%52v/
<
			Execute current line in shell.
yy			Yank line.
:!<C-R>"<ENTER>		Paste line after ! to run as command.
:.!sh			Now replace current line with the output results

K			Load man page for current word using /usr/bin/man by default.|K| |'keywordprg'|
{Visual}K		Load man page for visual selection. |v_K|
3K			Load section 3 of a man page, e.g. printf (3) instead of printf (1).
4K			Load section 4 of a man page, e.g. urandom (4) or console (4).
			Use 'q' to exit man, then press enter when it says >
				Press ENTER or type command to continue
<

:r !uname -r		Dump content of command into current buffer. |:read|
:%!uname -r		Make current buffer match content of command. |:%|

:tabnew|read !man ascii
			Open text of ascii (1) manpage as new tab.
			Note: older version of Vim might not format the text correctly.
	https://unix.stackexchange.com/questions/7672/man-ascii-is-misaligned-when-using-vim-as-a-pager
	http://www.unixcl.com/2007/05/opening-man-page-in-vim-linux.html

:read !date		Insert a new line with the date from the /bin/date command. |:read|
:read !date -I		Same, but with day only date in ISO format, e.g. 2014-07-22.
:r !date -I		Less typing.
!!date -I		Even less typing, but will overwrite current line. |:.|
			Looks like this: >
				:.!date -I

	http://stackoverflow.com/questions/56052/best-way-to-insert-timestamp-in-vim
	http://stackoverflow.com/a/7681121

:let @" = system("date")
			Yank the date into the unnamed register for easy pasting.

:ha > %.ps		Write a PostScript file instead of printing. |:hardcopy| |:_%|

r<CR>			Quickly split a line at a space without entering insert mode.
			Much faster than: >
				i<Enter><Esc>
<

:set nu			View line numbers. |'number'|

:set relativenumber	View relative line numbers. |'relativenumber'|

das			Delete a sentence (leaves no spaces behind). |das|
dis			Delete inner sentence (leaves a space behind). |dis|

z.			Center screen on cursor. |z.|

			Moving vertically.
5G			Jump to line 5 ("line 5, Go"). |G|
:5			Jump to line 5. |:range|
L			Jump to bottom of screen ("low"). |L|
M			Jump to middle of screen ("middle"). |M|
H			Jump to top of screen ("high"). |H|
zt			Put this line at the 't'op of the screen. |zt|
zb			Put this line at the 'b'ottom of the screen. |zb|
zz			Put this line at the middle of the screen. |zz|
50%			Go to a percentage of the file. |N%|

	http://vimuniversity.com/samples/jumping-long-distances

:help help-writing	The Vim documentation format. |help-writing|

$ vim + myfile.txt	Start editing at the end of a file/bottom of document/last line. |-+|

g;			Jump to last edited spot
g,			Jump to next edited spot
gv			Jump to last visual selection

Alt-o			Open new line while in insert mode.
			Only works in a terminal with Alt-sends-Escape,
			not in e.g. gVim.

:earlier 10s		Return to 10 seconds earlier. |:earlier|

:%s/\s\+$//		Delete all trailing whitespace.
/\S\s$			Search for trailing whitespace, ignoring a line that is only whitespace.
			*Todo	how can you jump to the whitespace, not one character to the left?
			*Todo	how can you turn this into a substitution command?

f<Space>		Jump to next space. |f|

ct<Space>		Change text till next space

/^V142			Search for decimal ascii value #142.
			Useful for getting rid of control characters in a text file,
			e.g. the control character U+008E <control> UTF-8: c2 8e  UTF-16BE: 008e  Decimal: &#142;
	http://en.wikipedia.org/wiki/%C2%8E

/CTRL-V CTRL-M		Search for DOS line feed (\r\n or <CR><NL>). |i_CTRL-V|

:%s/\r\+$//g		Remove DOS line feeds (\r\n). |/\r| |'fileformat'|
			*Todo	why does :help \\r also work?
	https://stackoverflow.com/questions/811193/how-to-convert-the-m-linebreak-to-normal-linebreak-in-a-file-opened-in-vim
	https://en.wikipedia.org/wiki/Newline

			Move by |word|s separated by spaces, punctuation, etc.
w			Forward to start of next word. |w|
e			Forward to end of current word. |e|
			Note: |word| is affected by |'iskeyword'|

			Moving by space-separated |WORD|s, not letters and underscores.
W			Forward to start of next word. |W|
E			Forward to end of current word. |E|


:set spell		Check spelling. |'spell'|

]s			Move to next misspelled word. |]s|

[s			Move back to previous misspelled word. |[s|

zg			Mark a word as spelled correctly (add a word to vim's dictionary). Mnemonic: good |zg| |spellfile|
			Note: Vim's personal dictionary is $HOME/.vim/spell/en.utf-8.add by default.

zw			Mark a word as misspelled (remove from vim's dictionary). Mnemonic: wrong. |zw|

:w !sudo tee > /dev/null %
			When you try to save and find you're editing a file without the needed permissions.

	https://stackoverflow.com/questions/1005/getting-root-permissions-on-a-file-inside-of-vi
	http://www.commandlinefu.com/commands/view/1204/save-a-file-you-edited-in-vim-without-the-needed-permissions
	https://stackoverflow.com/questions/2600783/how-does-the-vim-write-with-sudo-trick-work

Ctrl-W			Delete previous word in insert mode. |i_CTRL-W|

Ctrl-O			Access normal mode for one command, then go back to insert mode. |i_CTRL-O|

Ctrl-G u		Start new change in insert mode. |i_CTRL-G_u|
			This way, |u| (undo) doesn't delete everything.

:set shellcmdflag=-ic
			Access shell aliases from vim.

$ vim file1 file2 file3
			Opening multiple buffers with vim (not tabs)

:ls			See open buffers, one on each line. |:ls|
			(Windows and tabs are buffers, too.)
			Note: it would be nice if this gave you the option to select a buffer to move to,
			but unfortunately it does not; you just get Vim's built-in |pager|.
			*Todo	it is possible to search in Vim's pager?

			From the Vim documentation: >
			u	an unlisted buffer (only displayed when [!] is used) |unlisted-buffer|
			%	the buffer in the current window
			#	the alternate buffer for ":e #" and CTRL-^
			a	an active buffer: it is loaded and visible
			h	a hidden buffer: It is loaded, but currently not displayed in a window |hidden-buffer|
			-	a buffer with 'modifiable' off
			=	a readonly buffer
			+	a modified buffer
			x	a buffer with read errors
<
g<			Get back to the last page of command output. |g<|
			Useful if you accidentally hit <Enter> or <Space> too many times at the |more-prompt|.

:redir			Capture output of ex command. |:redir|
	http://vim.wikia.com/wiki/Capture_ex_command_output

			Capture open buffers into unnamed register. |ls| |:silent|
:redir @" | silent ls | redir END

			Make it easier to capture and edit complex options like |'iskeyword'|.
:redir @" | silent set iskeyword? | redir END
			Store contents of 'iskeyword' in the unnamed register, e.g. >
				^J  iskeyword=@,48-57,_,192-255
<			|:redir| |:silent| |:set| |'iskeyword'|
q:			Bring up the command-line window. |q:|
p			Paste the unnamed register. Will need to scroll down due to ^J character. |p|
<Enter>			After editing, execute the command. |E199|
			*Todo	why does the ^J character show up?

			Store all digraphs to file. |:digraphs|
:redir > digraphs.txt | silent digraphs | redir END
	https://stackoverflow.com/questions/2573021/how-to-redirect-ex-command-output-into-current-buffer-or-file

			Append contents of all registers to end of current file.
:redir >> % | silent registers | redir END | edit

:args			List arguments to vim when it was invoked.
			Will not include e.g. buffers opened with |:badd| or |:tabnew|.

:b <Tab>		Switch to a buffer using tab completion.

:new			Open a new empty, blank buffer.

:badd			Add a buffer from e.g. a different file.

:b#			Jump to last buffer.

@:			Repeat last colon command.

Ctrl-6			Jump to the alternate buffer. |CTRL-6|

			Select a folder or directory to enter rather than cycling through them. |c_End| |c_CTRL-E|
End			Or,
Ctrl-E


Ctrl-D			Show the options for the next completion (better than Ctrl-E). |c_CTRL-D|

:set wildmenu		Add tab-completion to new buffer |'wildmenu'|

:bd			Close a buffer. |:bd|

:bw			Wipe out a buffer. |:bw|


:sav file2.txt		Save/rename a file and start editing it instead of the current file. |:saveas|

$ vim -c "set list" file.txt
			Run :set list as soon as file.txt is loaded. |-c| |'list'|

$ vim -c "set backupcopy=yes|set noswapfile" myfile
			Set vim so that it will write a file in place rather than making a temp or backup file (.swp). |'backupcopy'| |'noswapfile'|


:m +4			Move current line down 4 lines. |:move|

/for.*done		Search for "for" and "done" in the same line. |/\.|
/computer.*fun		Search for computer and fun on the same line.

:vs.			Open a split window of current directory.

100go			Jump to the 100th byte. |go|
:goto 100		Same command in ex mode. |:goto|

:g/^$/d			Remove blank lines. |:global| |/^| |:d|
:g/^#/d			Remove lines starting with #.

			http://vim.wikia.com/wiki/Delete_all_lines_containing_a_pattern

			Macros and registers
qy			Start recording macro y
q			Stop recording macro y

:reg			See registers, including macros. Press <Enter> to see more and <Q> when finished.

@a			Run macro 'a'.

"ap			Paste macro 'a' onto current line.

{Visual}"ay		Yank visual selection into the 'a' register.


:%s/\%x85/\r/gc		Replace non-printing characters (high ascii), e.g. 0x85 with \r.

%:r			Get filename without extension. |%:r|
:!markdown % > %:r.html
			Use it in a script. |:!|
:w|!markdown % > %:r.html
			Run multiple commands with pipe |
			so we can write out and convert to html,
			excluding the .markdown extension.

p'[			Paste without moving cursor. |p| |'[|
	http://stackoverflow.com/questions/1587178/paste-in-vim-without-moving-the-cursor

:v/@/p			See all lines that don't contain the @ symbol.
			What this does is do a global search (equivalent to :g!)
			and execute the :p command for each matching line.

:v/@/d			Delete all lines that don't have the @ symbol. |:vglobal| |:d|

:diffu			Update the diffs for vimdiff. |:diffupdate|

			Delete last two chars of contiguous lines.
V{motion}
:s/..$//

g~~			Flip case of entire line. |g~~|

{Visual}:normal @a	Run the 'a' macro on each line of some visually selected text. |:normal|
			Looks like this: >
				:'<,'>normal @a
<

:g/vim/ normal @a	Run the 'a' macro on lines matching the 'vim' pattern
	http://blog.sanctum.geek.nz/advanced-vim-macros/

:%!column -t		Format current file using external /usr/bin/column program.

:s/\s//g		Remove all spaces on a line.

			Jumping to spaces.
F<space>		|F|
T<space>		|T|

			Overwriting a word with yanked text.
ye			Yank to end of word.
{move-around} 		Move to the word to replace.
ve			Visually select to end of word.
p			Overwrite word. |v_p|
			Note: this puts the overwritten word into the unnamed register. |quotequote|

			Edit a macro in the 'a' register.
"ap			Paste contents of the macro into the current buffer and edit away.
"add			When finished, delete the line back into the "a register.
			If it runs over multiple lines, use a visual selection.

:let @a='		Another way to edit a named macro; somewhat less convenient than the other way. |:let|
Ctrl-R Ctrl-R a		Modify as desired, then add a closing '''. Use double '' for literal ' inside, not \' |c_CTRL-R|
'			Press enter, and you're done. If it ends with <CR> or <NL>, though, you are in for trouble.

:set hidden		Abandon a buffer so it won't complain if you make changes and then leave without saving. |'hidden'|

!!echo %		Replace current line with filename.
			Looks like this: >
				:.!echo %
<
			Evaluate math expression on current line using external /usr/bin/bc command,
			replacing current line with the result.
1 + 1			Enter math expression.
!!bc			Evaluate with bc (integers only). Looks like this: >
				:.!bc
2			Get back result.
4195835 / 3145727	Enter a different math expression on a different line.
!!bc -l			Do 20 digits of floating point precision and load math library. Looks like this: >
				:.!bc
1.33382044913624100247	Get back result.
			You can also do calculations on multiple lines with a visual selection.
			Looks like this: >
				:'<,'>!bc -l

{Visual}g?		ROT13 a visual selection. |g?|

			ROT13 (Caesar cipher) with external rot13 command (in bsdgames package).
V{motion}		Select linewise with V.
!rot13			Send text to external command.
			Look like this when typed: >
				:'<,'>!rot13
>

Ctrl-l			Redraw screen. |CTRL-L|

!pandoc -t latex	Convert visual selection to LaTeX syntax by running it through the /usr/bin/pandoc command.
			For example, this will escape &, %, and # to \&, \%, and \#.

:set ft?		See what Vim reads the current filetype as. |'filetype'|
			Not to be confused with |'fileformat'|
			which sets DOS or Unix line endings.

			Choose vim's filetype. |:setfiletype| |filetypes|
:setf c			Set filetype for C or C++ source code. |c.vim| |ft-c-syntax|
:setf php		Set filetype for PHP source code. |php.vim|
:setf messages		Set filetype to messages, e.g. /var/log/syslog.
:set filetype=help	Force filetype to be a Vim help file. (also afffects syntax highlighting).  |help|

			Example filetype plugins locations: >
				/usr/share/vim/vimcurrent/ftplugin/
				/usr/share/vim/vimcurrent/ftplugin/c.vim
				/usr/share/vim/vimcurrent/ftplugin/lisp.vim
				/usr/share/vim/vimcurrent/ftplugin/python.vim
				/usr/share/vim/vimcurrent/ftplugin/sh.vim
				/usr/share/vim/vimcurrent/ftplugin/tex.vim
<
			Note that this is not all possible filetypes,
			e.g. crontab does not have its own filetype plugin.


:set syntax?		See what syntax highlighting Vim is using,
			even if syntax highlighting is off.
			This should be set by filetype. |'syntax'|

:sy off			Turn off syntax highlighting. |:syntax|
:set syn=off		Turn off syntax highlighting. |'syntax'|

			Force syntax highlight if e.g. file extension is wrong.
:set syntax=python	Python syntax. |ft-python-syntax|
:set syntax=rst		reStructuredText syntax.
:set syntax=markdown	Markdown syntax.
:set syntax=vim		Vimscript syntax.

			Example syntax plugin locations: >
				/usr/share/vim/vimcurrent/syntax/
				/usr/share/vim/vimcurrent/syntax/cpp.vim
				/usr/share/vim/vimcurrent/syntax/crontab.vim
				/usr/share/vim/vimcurrent/syntax/lisp.vim
				/usr/share/vim/vimcurrent/syntax/messages.vim
				/usr/share/vim/vimcurrent/syntax/perl6.vim
				/usr/share/vim/vimcurrent/syntax/python.vim
				/usr/share/vim/vimcurrent/syntax/sh.vim
<
			Some of these can get long; see the perl6 plugin, for example.

:verbose set modeline?
			See if modeline is enabled and why. |:verbose| |'modeline'| |E518|
			Could use modelines to enable syntax highlighting and so on,
			but mostly modeline is disabled by default for security reasons.
			Modelines are useful for e.g. setting the filetype even if the file
			extension is misleading. For example: >
				# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
<			in a python file will make the spacing come out right.
			Or this in a javascript file: >
				// vim: set ft=javascript:
<
	http://vim.wikia.com/wiki/Modeline_magic
	https://wiki.python.org/moin/Vim

			Getting help for different modes.
:help ctrl-f		What does CTRL-F do in normal mode?
:help i_ctrl-f		What does CTRL-F do in insert mode?
:help c_ctrl-f		What does CTRL-F do in command mode?
			Use tab to cycle through the various options.

gd			Go to local variable definition. |gd|

gD			Go to global variable definition. |gD|

:windo e		Reload (edit) all windows. |:windo| |:edit|
:buffdo e		Reload all buffers. |:bufdo|
:tabd e			Reload all tabs. |:tabdo|

:set autoread		Automatically keep buffers up to date,
			in case a program other than vim changes them. |'autoread'|

:setlocal autoread	 Keep only the current buffer up to date.

/\#\a			Search for # followed by an alphabetic character. |/\a|

			Vim regular expressions for searching. |/character-classes| |/ordinary-atom|
			.  any character except new line |whitespace|
			\s whitespace character          |/\s|
			\S non-whitespace character      etc.
			\d digit
			\D non-digit
			\x hex digit
			\X non-hex digit
			\o octal digit
			\O non-octal digit
			\h head of word character (a,b,c...z,A,B,C...Z and _)
			\H non-head of word character
			\p printable character
			\P like \p, but excluding digits
			\w word character
			\W non-word character
			\a alphabetic character
			\A non-alphabetic character
			\l lowercase character
			\L non-lowercase character
			\u uppercase character
			\U non-uppercase character
	http://vimregex.com/#metacharacters
	

:set softtabstop=4 shiftwidth=4 expandtab smartindent
			Basic vim indentation for e.g. python. |ft-python-indent|
			softtabstop is how many columns vim moves when you press tab. |'softtabstop'|
			shiftwidth controls >> << and cindent                         |'shiftwidth'|
			expandtab produces spaces when the tab key is pressed         |'expandtab'|
	http://tedlogan.com/techblog3.html

			Example indentation plugin locations: >
				/usr/share/vim/vimcurrent/indent/
				/usr/share/vim/vimcurrent/indent/c.vim
				/usr/share/vim/vimcurrent/indent/lisp.vim
				/usr/share/vim/vimcurrent/indent/python.vim
				/usr/share/vim/vimcurrent/indent/sh.vim
<

Ctrl-V <tab>		Insert literal tab when expandtab is on. |i_CTRL-V|
	http://blog.swwomm.com/2011/01/literal-tabs-in-vi.html

Ctrl-V 0 <enter>	Insert literal null character. |i_CTRL-V_digit|

/\#\a			Search for # followed by a letter (not a space). |/\a|

:%s/\#\(\a\)/\# \1/gc
			Search for # followed by a letter,
			then put a space between them. |/\1| |/\(\)|


$ vim -r myfile.txt	Recovering swap files. |E325|
			Note: a typical recovery message looks like this: >
				E325: ATTENTION
				Found a swap file by the name ".myfile.txt.swp"
				          owned by: user   dated: Tue Feb 10 09:28:48 2015
				         file name: /tmp/myfile.txt
				          modified: YES
				         user name: user   host name: laptop
				        process ID: 9670
				While opening file "myfile.txt"
				
				(1) Another program may be editing the same file.  If this is the case,
				    be careful not to end up with two different instances of the same
				    file when making changes.  Quit, or continue with caution.
				(2) An edit session for this file crashed.
				    If this is the case, use ":recover" or "vim -r myfile.txt"
				    to recover the changes (see ":help recovery").
				    If you did this already, delete the swap file ".myfile.txt.swp"
				    to avoid this message.
				
				Swap file ".myfile.txt.swp" already exists!
				[O]pen Read-Only, (E)dit anyway, (R)ecover, (D)elete it, (Q)uit, (A)bort:
<			The most important lines are "process ID" and "modified".
			If another copy of vim is still running, it will look like, e.g.: >
        			process ID: 9526 (still running)
>			If the file hasn't been modified, it will say this: >
          			modified: no
>			This means it is safe to delete the swap file.
			Note: vim swap files (.swp) don't hold edit history,
			so if you do a vim -r myfile.txt,
			you'll have to output the resulting file and diff it,
			not press u and Ctrl-R to run through the history.
			There will be no history. |swap-file| >
				The swap file is updated after typing 200 characters or when you have not
				typed anything for four seconds.  This only happens if the buffer was
				changed, not when you only moved around.
<			Note that vim swap files are not always portable between machines,
			and attempting to open swap files from other machines may lead to error like this: >
				.file.txt.swp cannot be used on this computer.
				The file was created on <hostname>,
				or the file has been damaged.
<	https://groups.google.com/forum/#!msg/vim_use/-wKUzSTun04/4Gu6cXUkKwUJ

:source $MYVIMRC	Reload the vimrc file. |:source| |$MYVIMRC|

:bn			Go to next buffer. |:bnext|
			Note that you must save the file first,
			unlike going to the next tab. |E37|


.			Repeat last change or yank. |.|
@:			Repeat last colon command. |@:|
@@			Repeat last colon command again. |@@|

	*Todo	any way to repeat last movement?
	http://vim.1045645.n5.nabble.com/How-to-repeat-the-last-movement-command-td1173323.html
	http://vim.sourceforge.net/scripts/script.php?script_id=2174

			Disable arrow keys. |:nnoremap|
			Usually added to ~/.vimrc file,
			in which case the leading colons are not necessary. |vimrc|
:nnoremap <up> <nop>	|<Up>| |<Nop>|
:nnoremap <down> <nop>	|<Down>|
:nnoremap <left> <nop>  |<Left>|
:nnoremap <right> <nop> |<Right>|
	https://stackoverflow.com/questions/23548932/how-do-i-disable-the-arrow-keys-in-insert-mode

:mks! /tmp/current.ses
			Saving a vim session, overwriting old sessions. |:mksession|
			Note that this does not preserve history.
			(For that, you will need |viminfo|.)

$ vim -S /tmp/current.ses
			Restore that same session. |-S|

			Fix indentation for an entire file. |=| |filter|
gg			Go to top of file. |gg|
=G			Filter all lines to bottom of file through default indentation program. |G|
	http://vim.wikia.com/wiki/Fix_indentation

:set nostartofline	Stop jumping to start of line when using |jump-motions|.
	http://stackoverflow.com/questions/16748161/jump-to-last-line-but-stay-in-the-same-column

q:			Show command history as an editable vim window. |q:|
			Press <Enter> to execute the command the cursor is on,
			or Ctrl-C to quit. |c_CTRL-C|
			
			Example of how this is useful: it gets you insert-mode editing for free.
q:			Open up the command history.
i			Enter insert mode. |i|
:s/			Start a substitution command. Can also use <Tab> to autocomplete.
{char}			Start typing the name of the keyword.
Ctrl-n			Autocomplete the name of the keyword. |i_CTRL-N|
/replacement/		Finish typing the substition command.
<Enter>			Execute the substitution command.
	https://stackoverflow.com/questions/19730567/vim-auto-completion-on-substitutions-and-searches-in-the-command-line

q/			Show search history as an editable vim window. |q/|
			Press <Enter> to choose that search line,
			or Ctrl-C to quit. |CTRL-C|

gq			Reflow/wrap/format the selected text. |gq|
			Useful for hard-wrapping long lines.

gqq			Reflow/wrap/format only the line under the cursor. |gqq|
			Note: easily mistyped with |gQ|, which means go into |Ex-mode|.

Ctrl-L			Autocomplete in incremental search mode. |c_CTRL-L|

==============================================================================
 vim:ft=help:norl:
